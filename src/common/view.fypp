! view.fypp --
!     Very rough!!!
!
module ndim_storage
    implicit none

    type ndim_type
        integer, dimension(:), allocatable :: shape
        integer, dimension(:), pointer     :: parray
    contains
        procedure :: point_to => point_to_any_rank
        procedure :: elem     => elem_of
    end type ndim_type

    interface shape
        module procedure shape_ndim
    end interface

contains

rank default
this%parray => array
this%shape = shape(array)





subroutine point_to_any_rank( this, array )
    class(ndim_type), intent(inout) :: this
    integer, dimension(..), target  :: array

    integer, dimension(5) :: shp

    this%rank = rank(array)

    select rank ( array )
        rank (1)
            shp(1:1) = shape(array)
            this%parray(1:shp(1),1:1,1:1,1:1,1:1) => array
        rank (2)
            shp(1:2) = shape(array)
            this%parray(1:shp(1),1:shp(2),1:1,1:1,1:1) => array
        rank (3)
            shp(1:3) = shape(array)
            this%parray(1:shp(1),1:shp(2),1:shp(3),1:1,1:1) => array
        rank (4)
            shp(1:4) = shape(array)
            this%parray(1:shp(1),1:shp(2),1:shp(3),1:shp(4),1:1) => array
        rank (5)
            shp(1:5) = shape(array)
            this%parray(1:shp(1),1:shp(2),1:shp(3),1:shp(4),1:shp(5)) => array
        rank default
            write(*,*) 'Rank not supported'
            error stop
    end select

    write(*,*) 'Rank: ', rank(array)
end  subroutine point_to_any_rank

function shape_ndim( store ) result( shp )
    type(ndim_type), intent(in) :: store

    integer, allocatable, dimension(:) :: shp

    shp = shape(store%parray)
    shp = shp(1:store%rank)

end function shape_ndim
!
! Note: no check whether too many indices are given
!
integer function elem1to5d( store, idx1, idx2, idx3, idx4, idx5 )
    class(ndim_type), intent(in)  :: store
    integer, intent(in)           :: idx1
    integer, intent(in), optional :: idx2
    integer, intent(in), optional :: idx3
    integer, intent(in), optional :: idx4
    integer, intent(in), optional :: idx5

    select case( store%rank )
        case( 1 )
            elem1to5d = store%parray(idx1,1,1,1,1)
        case( 2 )
            if ( .not. present(idx2) ) error stop
            elem1to5d = store%parray(idx1,idx2,1,1,1)
        case( 3 )
            if ( .not. present(idx3) ) error stop
            elem1to5d = store%parray(idx1,idx2,idx3,1,1)
        case( 4 )
            if ( .not. present(idx4) ) error stop
            elem1to5d = store%parray(idx1,idx2,idx3,idx4,1)
        case( 5 )
            if ( .not. present(idx5) ) error stop
            elem1to5d = store%parray(idx1,idx2,idx3,idx4,idx5)
    end select

end function elem1to5d

end module ndim_storage

program anyrank_uniform
    use ndim_storage
    implicit none

    type(ndim_type) :: store
    integer               :: i
    integer, dimension(3) :: shp = [2,2,2]

    ! This does not work ...
    !do i = 1,size(shp)
    !    call store%point_to( reshape( [1,2,3,4,5,6,7,8], shp(1:i) ) )
    !enddo

    call store%point_to( [1,2,3,4,5,6,7,8] )                     ; write(*,*) '1 -- shape:', shape(store), store%elem(2)
    call store%point_to( reshape( [1,2,3,4,5,6,7,8], [2,4] ) )   ; write(*,*) '2 -- shape:', shape(store), store%elem(2,2)
    call store%point_to( reshape( [1,2,3,4,5,6,7,8], [2,2,2] ) ) ; write(*,*) '3 -- shape:', shape(store), store%elem(2,2,2)
end program anyrank_uniform
